(import (rnrs sorting (6))
	(rnrs io ports (6))
	(rnrs lists (6)))
(define (read-list-pair)
  (let loop ((list-pair (cons '() '())))
    (let ((left (read)))
      (if (eof-object? left)
	  list-pair
	  (let ((right (read)))
	    (loop (cons (append (car list-pair) (list left))
			(append (cdr list-pair) (list right)))))))))
(define (total-distance lst1 lst2)
  (fold-left + 0
	     (map (lambda (x y) (abs (- x y)))
		  (list-sort < lst1)
		  (list-sort < lst2))))
;; maybe it's better to use procedural style
(define (similarity-score lst1 lst2)
  (let loop
      ((l1 (list-sort < lst1))
       (l2 (list-sort < lst2))
       (score 0))
    (if (or (null? l1) (null? l2))
	score
	(cond ((< (car l1) (car l2))
	       (loop (cdr l1) l2 score))
	      ((> (car l1) (car l2))
	       (loop l1 (cdr l2) score))
	      ((= (car l1) (car l2))
	       (let pop-repetitions1 ((elem (car l1)) (l1count 0) (l1 l1))
		 (if (or (null? l1) (not (= elem (car l1))))
		     (let pop-repetitions2 ((elem (car l2)) (l2count 0) (l2 l2))
		       (if (or (null? l2) (not (= elem (car l2))))
			   (loop l1 l2 (+ score (* elem l1count l2count)))
			   (pop-repetitions2 elem (+ 1 l2count) (cdr l2))))
		     (pop-repetitions1 elem (+ 1 l1count) (cdr l1)))))))))
(let ((list-pair (read-list-pair)))
  (write (total-distance (car list-pair) (cdr list-pair)))
  (newline)
  (write (similarity-score (car list-pair) (cdr list-pair)))
  (newline))
